<script>
const GRID = /* keep your existing GRID as-is */;
const ROWS = 40;
const COLS = 40;
const NUMBERS = /* keep your existing NUMBERS as-is */;

/* ========= OBFUSCATED ANSWERS (base64) =========
   We decode these once at runtime so the UI & logic stay identical.
*/
const ACROSS = [
  {"num": 1, "cells": [[10,14],[10,15],[10,16],[10,17],[10,18],[10,19],[10,20]], "answer": "R1VFVkFSQQ=="},
  {"num": 2, "cells": [[13,6],[13,7],[13,8],[13,9],[13,10],[13,11]], "answer": "TUFOREVMQQ=="},
  {"num": 3, "cells": [[20,10],[20,11],[20,12],[20,13],[20,14],[20,15],[20,16],[20,17],[20,18],[20,19]], "answer": "V0FTSElOR1RPTg=="}
];

const DOWN = [
  {"num": 4, "cells": [[3,16],[4,16],[5,16],[6,16],[7,16],[8,16],[9,16],[10,16]], "answer": "Vk9MVEFJUkU="},
  {"num": 5, "cells": [[7,14],[8,14],[9,14],[10,14],[11,14],[12,14]], "answer": "S0lOR0pS"},
  {"num": 6, "cells": [[8,15],[9,15],[10,15],[11,15],[12,15],[13,15],[14,15],[15,15],[16,15]], "answer": "Q0hVUkNISUxM"},
  {"num": 7, "cells": [[12,7],[13,7],[14,7],[15,7],[16,7],[17,7],[18,7]], "answer": "TUFOREVMQQ=="},
  {"num": 8, "cells": [[14,12],[15,12],[16,12],[17,12],[18,12],[19,12],[20,12],[21,12],[22,12]], "answer": "SkVGRkVSU09O"},
  {"num": 9, "cells": [[19,14],[20,14],[21,14],[22,14],[23,14],[24,14],[25,14]], "answer": "TElOQ09MTg=="}
];

/* Clues: keys are obfuscated too (base64); we decode once into CLUES. */
const CLUES = {};
const CLUES_ENC = {
  "V0FTSElOR1RPTg==": "First leader crossing the Delaware, standing tall in stone",
  "SkVGRkVSU09O": "Author of independence, remembered by a domed memorial",
  "TElOQ09MTg==": "Freed the enslaved, seated forever on the National Mall",
  "Uk9PU0VWRUxU": "Four freedoms, wheelchair, and fireside resolve",
  "R1JBTlQ=": "Civil War general honored on horseback by the Capitol",
  "RkRS": "New Deal initials, memorial by the Tidal Basin",
  "TUFOREVMQQ==": "From prisoner to president of freedom in South Africa",
  "R0FOREhJ": "Led independence through non-violence and salt marches",
  "Q0hVUkNISUxM": "‘We shall never surrender’—wartime PM cast in bronze",
  "R1VFVkFSQQ==": "Cuban revolutionary, iconic mural face",
  "S0lOR0pS": "Dreamer whose memorial looks toward Lincoln",
  "Vk9MVEFJUkU=": "Enlightenment wit resting in Paris’s Panthéon"
};

/* ========== One-time deobfuscation (keeps behavior identical) ========== */
(function deobfuscateOnce(){
  const b64 = (s)=> atob(s);

  // Decode entry answers
  [ACROSS, DOWN].forEach(list=>{
    list.forEach(e=>{
      // If it looks like base64, decode to real answer text.
      if (/^[A-Za-z0-9+/=]+$/.test(e.answer)) e.answer = b64(e.answer);
    });
  });

  // Decode clue keys into CLUES object
  Object.keys(CLUES_ENC).forEach(k=>{
    CLUES[b64(k)] = CLUES_ENC[k];
  });
})();

/* === the rest of your ORIGINAL script stays the same from here === */

const gridEl = document.getElementById('grid');

function idFor(r,c){ return `r${r}c${c}`; }

function buildGrid(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell = GRID[r][c];
      const div = document.createElement('div');
      div.className = 'cell' + (cell.blocked ? ' block' : '');
      if(!cell.blocked){
        const numTxt = NUMBERS[r][c];
        if(numTxt){
          const n = document.createElement('div');
          n.className='num'; n.textContent = numTxt;
          div.appendChild(n);
        }
        const inp = document.createElement('input');
        inp.setAttribute('maxlength','1');
        inp.dataset.r = r; inp.dataset.c = c;
        inp.id = idFor(r,c);
        inp.addEventListener('input', (e)=>{
          e.target.value = e.target.value.toUpperCase().replace(/[^A-Z]/g,'');
        });
        inp.addEventListener('keydown', (e)=>{
          if(e.key === 'ArrowLeft'){ e.preventDefault(); move(r,c,0,-1); }
          else if(e.key === 'ArrowRight'){ e.preventDefault(); move(r,c,0,1); }
          else if(e.key === 'ArrowUp'){ e.preventDefault(); move(r,c,-1,0); }
          else if(e.key === 'ArrowDown'){ e.preventDefault(); move(r,c,1,0); }
          else if(e.key === 'Backspace'){
            if(!e.target.value){ e.preventDefault(); move(r,c,0,-1,true); }
            else { e.target.value=''; e.preventDefault(); }
          }
        });
        div.appendChild(inp);
      }
      gridEl.appendChild(div);
    }
  }
}

function move(r,c,dr,dc,clearPrev=false){
  let nr=r, nc=c;
  while(true){
    nr += dr; nc += dc;
    if(nr<0||nc<0||nr>=ROWS||nc>=COLS) return;
    if(!GRID[nr][nc].blocked){
      const el = document.getElementById(idFor(nr,nc));
      if(el){
        el.focus();
        if(clearPrev) el.value='';
      }
      return;
    }
  }
}

function clearAll(){
  document.querySelectorAll('.cell input').forEach(i=> i.value='');
}

function checkAll(){
  let correct=0, total=0;
  document.querySelectorAll('.cell input').forEach(inp=>{
    const r = +inp.dataset.r, c = +inp.dataset.c;
    const want = (GRID[r][c].solution || '').toUpperCase();
    const got = (inp.value||'').toUpperCase();
    if(want){
      total++;
      inp.style.boxShadow = (got===want) ? 'inset 0 0 0 2px #1dd881' : 'inset 0 0 0 2px #ff4d6d';
    } else {
      inp.style.boxShadow = 'inset 0 0 0 1px #cfd3dc';
    }
    if(got===want && want) correct++;
  });
  const pct = total ? Math.round(100*correct/total) : 0;
  alert(`Checked: ${correct}/${total} letters correct (${pct}%).`);
}

function renderClues(){
  const acrossEl = document.getElementById('across');
  const downEl = document.getElementById('down');
  const makeClue = (entry, dir)=>{
    const ans = (entry.answer||'').toUpperCase();
    const clueText = CLUES[ans] || `Clue for ${ans||'(unknown)'}`;
    const div = document.createElement('div');
    div.className = 'clue';
    div.dataset.dir = dir;
    div.dataset.num = entry.num;
    const len = entry.cells.length;
    div.textContent = `${entry.num}. ${clueText} (${len})`;
    div.addEventListener('click', ()=> highlightEntry(entry, dir, div));
    return div;
  };
  ACROSS.forEach(e=> acrossEl.appendChild(makeClue(e,'A')));
  DOWN.forEach(e=> downEl.appendChild(makeClue(e,'D')));
}

let activeCells = [];
function highlightEntry(entry, dir, clueEl){
  activeCells.forEach(([r,c])=>{
    const el = document.getElementById(idFor(r,c));
    if(el) el.parentElement.classList.remove('highlight');
  });
  document.querySelectorAll('.clue').forEach(el=> el.classList.remove('active'));
  clueEl.classList.add('active');
  activeCells = entry.cells;
  entry.cells.forEach(([r,c])=>{
    const el = document.getElementById(idFor(r,c));
    if(el) el.parentElement.classList.add('highlight');
  });
  if(entry.cells.length){
    const [r,c] = entry.cells[0];
    const el = document.getElementById(idFor(r,c));
    if(el) el.focus();
  }
}

document.getElementById('btn-clear').addEventListener('click', clearAll);
document.getElementById('btn-check').addEventListener('click', checkAll);
document.getElementById('btn-save').addEventListener('click', ()=>{
  const data=[];
  document.querySelectorAll('.cell input').forEach(inp=>{
    data.push({r:+inp.dataset.r, c:+inp.dataset.c, v:(inp.value||'').toUpperCase()});
  });
  const blob = new Blob([JSON.stringify({rows:ROWS, cols:COLS, data}, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'crossword_progress.json'; a.click();
  URL.revokeObjectURL(url);
});
document.getElementById('btn-load').addEventListener('click', ()=>{
  const inp = document.createElement('input');
  inp.type = 'file'; inp.accept = 'application/json';
  inp.addEventListener('change', ()=>{
    const f = inp.files[0];
    const reader = new FileReader();
    reader.onload = ()=>{ try{
      const obj = JSON.parse(reader.result);
      obj.data.forEach(o=>{
        const el = document.getElementById(idFor(o.r,o.c));
        if(el) el.value = (o.v||'').toUpperCase();
      });
    }catch(err){ alert('Import failed: ' + err.message); } };
    reader.readAsText(f);
  });
  inp.click();
});

buildGrid();
renderClues();

/* --- Gold glow logic (unchanged) --- */
(function(){
  function idFor(r,c){ return 'r'+r+'c'+c; }
  function isPuzzleComplete(){
    try{
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const want = (GRID[r][c].solution||'').toUpperCase();
          if(!GRID[r][c].blocked){
            const el = document.getElementById(idFor(r,c));
            const got = (el && el.value ? el.value.toUpperCase() : '');
            if(got !== want) return false;
          }
        }
      }
      return true;
    }catch(e){ return false; }
  }
  function getJeffersonCells(){
    const entries = [];
    if (typeof ACROSS !== 'undefined' && Array.isArray(ACROSS)) entries.push(...ACROSS);
    if (typeof DOWN   !== 'undefined' && Array.isArray(DOWN))   entries.push(...DOWN);
    for(const e of entries){
      const ans = (e.answer||'').toUpperCase();
      if(ans === 'JEFFERSON'){
        return Array.isArray(e.cells) ? e.cells : [];
      }
    }
    const target = 'JEFFERSON';
    for(let c=0;c<COLS;c++){
      for(let r=0;r<ROWS;r++){
        if(r>0 && !GRID[r-1][c].blocked) continue;
        let ok=true, cells=[];
        for(let i=0;i<target.length;i++){
          const rr=r+i;
          if(rr>=ROWS || GRID[rr][c].blocked || (GRID[rr][c].solution||'').toUpperCase()!==target[i]) { ok=false; break; }
          cells.push([rr,c]);
        }
        if(ok) return cells;
      }
    }
    return [];
  }
  const jeffCells = getJeffersonCells();
  function setGold(on){
    jeffCells.forEach(([r,c])=>{
      const el = document.getElementById(idFor(r,c));
      if(el){
        const tile = el.parentElement;
        if(tile){
          if(on) tile.classList.add('gold');
          else tile.classList.remove('gold');
        }
      }
    });
  }
  function checkAndGlow(){ setGold(isPuzzleComplete()); }
  document.addEventListener('input', e=>{
    if(e.target && e.target.tagName === 'INPUT'){
      setTimeout(checkAndGlow, 0);
    }
  }, true);
  var btnCheck = document.getElementById('btn-check');
  if(btnCheck){ btnCheck.addEventListener('click', ()=> setTimeout(checkAndGlow, 0)); }
  setGold(false);
})();
</script>
